{{- $job := .Values.minio.tenant.configSecret.configGeneratorJob -}}
{{- $target := .Values.minio.tenant.configSecret -}}
{{- $targetSecretName := $target.name -}}
{{- $sourceSecretName := default (include "atlas-cmms.fullname-minio" $) $job.sourceSecret.name -}}
{{- $accessKeyField := $job.sourceSecret.keyMapping.accessKey -}}
{{- $secretKeyField := $job.sourceSecret.keyMapping.secretKey -}}
{{- $restartMinio := $job.restartMinio | default false -}}
{{- if and $target.existingSecret $job.enabled -}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "atlas-cmms.fullname-minio" . }}-config-secret-generator
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/sync-wave: '-1'
    checksum/source-secret: {{ printf "%s:%s:%s" $sourceSecretName $accessKeyField $secretKeyField | sha256sum }}
spec:
  template:
    spec:
      restartPolicy: OnFailure
      containers:
        - name: secrets-generator
          image: {{ $job.image | default "alpine/kubectl:1.27.5" }}
          command:
            - /bin/sh
            - -c
            - |
              set -euo pipefail

              NAMESPACE="{{ .Release.Namespace }}"
              TARGET_SECRET_NAME="{{ $targetSecretName }}"
              SOURCE_SECRET_NAME="{{ $sourceSecretName }}"
              ACCESS_KEY_FIELD="{{ $accessKeyField }}"
              SECRET_KEY_FIELD="{{ $secretKeyField }}"
              RESTART_MINIO="{{ $restartMinio }}"

              echo "Checking source secret $SOURCE_SECRET_NAME in namespace $NAMESPACE..."
              if ! kubectl get secret "$SOURCE_SECRET_NAME" -n "$NAMESPACE" > /dev/null 2>&1; then
                echo "Source secret $SOURCE_SECRET_NAME not found, exiting."
                exit 1
              fi

              ACCESS_KEY=$(kubectl get secret "$SOURCE_SECRET_NAME" -n "$NAMESPACE" -o jsonpath="{.data.${ACCESS_KEY_FIELD}}" | base64 -d)
              SECRET_KEY=$(kubectl get secret "$SOURCE_SECRET_NAME" -n "$NAMESPACE" -o jsonpath="{.data.${SECRET_KEY_FIELD}}" | base64 -d)

              if kubectl get secret "$TARGET_SECRET_NAME" -n "$NAMESPACE" > /dev/null 2>&1; then
                OLD_CONFIG_HASH=$(kubectl get secret "$TARGET_SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.config\.env}' | base64 -d | sha256sum | awk '{print $1}')
              else
                OLD_CONFIG_HASH=""
              fi

              cat > /tmp/config.env <<EOF
              export MINIO_ROOT_USER=${ACCESS_KEY}
              export MINIO_ROOT_PASSWORD=${SECRET_KEY}
              EOF

              kubectl create secret generic "$TARGET_SECRET_NAME" \
                --from-file=config.env=/tmp/config.env \
                -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
              echo "Secret $TARGET_SECRET_NAME in namespace $NAMESPACE created/updated successfully."

              NEW_CONFIG_HASH=$(sha256sum /tmp/config.env | awk '{print $1}')

              if [ "$OLD_CONFIG_HASH" != "$NEW_CONFIG_HASH" ]; then
                  echo "Configuration has changed."
                  if [ "$RESTART_MINIO" = "true" ]; then
                      echo "Restart enabled, rolling restart of all MinIO StatefulSets for tenant {{ .Values.minio.tenant.name }}..."
                      for sts in $(kubectl get statefulsets -n "$NAMESPACE" -l "v1.min.io/tenant={{ .Values.minio.tenant.name }}" -o name); do
                          echo "Restarting $sts..."
                          kubectl rollout restart "$sts" -n "$NAMESPACE"
                      done
                  else
                      echo "Restart disabled, skipping StatefulSet restart."
                  fi
              else
                  echo "Configuration has not changed, no restart needed."
              fi
{{- end }}